"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const authorize_account_1 = require("./api-operations/authorize-account");
const errors_1 = tslib_1.__importDefault(require("./errors"));
const bucket_1 = tslib_1.__importDefault(require("./bucket"));
const { version } = require("../package.json");
let B2 = /** @class */ (() => {
    class B2 {
        constructor(credentials) {
            this.credentials = credentials;
        }
        /**
         * Backblaze allows uploading files as a single-part or as multiple parts.
         * However, you must know the length of each file in advance, and you cannot
         * use chunked-encoding. Single-part uploads are generally faster for smaller files.
         * Backblaze recommends a part-size, which is automatically used.
         *
         * Each part must be read into memory.
         *
         * You can configure this, to a minimum of `b2.auth.absoluteMinimumPartSize`.
         */
        get partSize() {
            return typeof this._userSetPartSize !== "undefined"
                ? Math.max(this._userSetPartSize, this.auth.absoluteMinimumPartSize)
                : this.auth.recommendedPartSize;
        }
        set partSize(size) {
            this._userSetPartSize = size;
        }
        async authorize() {
            this.auth = await authorize_account_1.authorize(this.credentials);
        }
        /**
         * Create a new B2 client by authorizing with the API.
         *
         * ```js
         * import B2 from "./src/b2";
         *
         * const b2 = await B2.authorize({
         *   applicationKeyId: "KEY_ID",
         *   applicationKey: "SECRET_KEY"
         * });
         * ```
         */
        static async authorize(credentials) {
            const b2 = new B2(credentials);
            await b2.authorize();
            return b2;
        }
        /** @internal */
        static uriEncodeString(decoded) {
            return encodeURIComponent(decoded).replace(/%2F/g, "/");
        }
        /** @internal */
        static uriDecodeString(encoded) {
            return decodeURIComponent(encoded).replace(/\+/g, " ");
        }
        async request(url, request, _options, retries = 0) {
            const options = { maxRetries: 5, backoff: 150, ..._options };
            const { maxRetries, backoff } = options;
            let res;
            try {
                res = await node_fetch_1.default(url, {
                    ...request,
                    headers: {
                        ...request.headers,
                        Authorization: this.auth.authorizationToken,
                        "User-Agent": B2.userAgent,
                    },
                });
            }
            catch (_a) {
                return new Promise((res, rej) => {
                    setTimeout(() => {
                        this.request(url, request, { ...options, backoff: backoff * 2 }, retries + 1).then(res, rej);
                    }, backoff * (0.5 + Math.random()));
                });
            }
            if (res.status === 200) {
                return res;
            }
            else {
                const data = (await res.json());
                switch (data.code) {
                    case "bad_request":
                        throw new errors_1.default.BadRequest(data);
                    case "unauthorized":
                        throw new errors_1.default.UnauthorizedRequest(data);
                    case "download_cap_exceeded":
                        throw new errors_1.default.DownloadCapExceeded(data);
                    case "bad_auth_token":
                    case "expired_auth_token":
                        if (retries < maxRetries) {
                            await this.authorize();
                            return this.request(url, request, options, retries + 1);
                        }
                        else {
                            throw new errors_1.default.ExpiredCredentials(data);
                        }
                    default:
                        switch (data.status) {
                            case 400:
                                throw new errors_1.default.BadRequest(data);
                            case 403:
                                throw new errors_1.default.Forbidden(data);
                            case 416:
                                throw new errors_1.default.RangeNotSatisfiable(data);
                            case 500:
                                throw new errors_1.default.InternalServerError(data);
                            case 408:
                                if (retries >= maxRetries)
                                    throw new errors_1.default.RequestTimeout(data);
                            case 500:
                                if (retries >= maxRetries)
                                    throw new errors_1.default.InternalServerError(data);
                            case 503:
                                if (retries >= maxRetries)
                                    throw new errors_1.default.ServiceUnavailable(data);
                                return new Promise((res, rej) => {
                                    setTimeout(() => {
                                        this.request(url, request, { ...options, backoff: backoff * 2 }, retries + 1).then(res, rej);
                                    }, backoff * (0.5 + Math.random()));
                                });
                            default:
                                throw new errors_1.default.UnknownServerError(data);
                        }
                }
            }
        }
        /** Call a b2 operation by name */
        async callApi(operationName, request, opts = {}) {
            const url = [this.auth.apiUrl, "b2api", B2.apiVersion, operationName].join("/");
            return this.request(url, request, opts);
        }
        /** @internal */
        async callDownloadApi(operationName, request, opts = {}) {
            const url = [
                this.auth.downloadUrl,
                "b2api",
                B2.apiVersion,
                operationName,
            ].join("/");
            return this.request(url, request, opts);
        }
        /** @internal */
        async requestFromDownloadFileByName(bucketName, fileName, request, opts = {}) {
            const url = [this.auth.downloadUrl, "file", bucketName, fileName].join("/");
            return this.request(url, request, opts);
        }
        async bucket(info) {
            return new bucket_1.default(this, typeof info === "string" ? { bucketName: info } : info);
        }
    }
    B2.apiVersion = "v2";
    B2.userAgent = `b2-js/${version}+nodejs/${process.version} https://git.io/b2-js`;
    return B2;
})();
exports.default = B2;
//# sourceMappingURL=b2.js.map