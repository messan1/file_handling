"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const b2_1 = tslib_1.__importDefault(require("./b2"));
const errors_1 = tslib_1.__importStar(require("./errors"));
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const append_hash_stream_1 = tslib_1.__importDefault(require("./append-hash-stream"));
/** @internal */
class SinglePartUpload {
    constructor(bucket, info) {
        this._inUse = false;
        this.bucket = bucket;
        this.info = info;
    }
    get inUse() {
        return this._inUse;
    }
    /** Create a new single part uploader by requesting a new upload url from B2. */
    static async requestNew(bucket) {
        const res = await bucket.b2.callApi("b2_get_upload_url", {
            method: "POST",
            body: JSON.stringify({
                bucketId: await bucket.getBucketId(),
            }),
        });
        const info = await res.json();
        return new SinglePartUpload(bucket, info);
    }
    /** @private */
    async _upload(fileName, data, options, retries) {
        let { fileInfo, contentType = "application/octet-stream", sha1, contentLength, maxRetries = 5, backoff = 150, } = options;
        if (typeof sha1 === "undefined") {
            const stream = new append_hash_stream_1.default("sha1");
            if (data instanceof Buffer) {
                stream.end(data);
            }
            else {
                data.pipe(stream);
            }
            sha1 = "hex_digits_at_end"; // Let B2 know we'll be deferring the hash.
            data = stream;
            contentLength += 40; // Length of the hash
        }
        const headers = {
            Authorization: this.info.authorizationToken,
            "X-Bz-File-Name": b2_1.default.uriEncodeString(fileName),
            "Content-Type": contentType,
            "Content-Length": contentLength.toString(),
            "X-Bz-Content-Sha1": sha1,
            "User-Agent": b2_1.default.userAgent,
        };
        if (typeof fileInfo !== "undefined") {
            for (const key in fileInfo) {
                if (fileInfo.hasOwnProperty(key)) {
                    const val = fileInfo[key];
                    if (typeof val !== "undefined")
                        headers["X-Bz-Info-" + key] = val;
                }
            }
        }
        const res = await node_fetch_1.default(this.info.uploadUrl, {
            method: "POST",
            headers,
            body: data,
        });
        const resData = await res.json();
        switch (res.status) {
            case 200:
                return resData;
            case 400:
                throw new errors_1.default.BadRequest(resData);
            case 401:
                if (resData.code === "bad_auth_token" ||
                    resData.code === "expired_auth_token") {
                    return false;
                }
                else {
                    throw new errors_1.default.UnauthorizedRequest(resData);
                }
            case 403:
                throw new errors_1.default.UsageCapExceeded(resData);
            case 408 /** timeout */:
                if (retries >= maxRetries)
                    throw new errors_1.default.RequestTimeout(resData);
            case 429 /** rate-limit */:
                if (retries >= maxRetries)
                    throw new errors_1.default.TooManyRequests(resData);
                const timeout = backoff * Math.pow(2, retries) * (0.5 + Math.random());
                return new Promise((res, rej) => {
                    setTimeout(() => {
                        this._upload(fileName, data, { ...options, contentLength }, retries + 1).then(res, rej);
                    }, timeout);
                });
            case 405:
                throw new errors_1.BackblazeLibraryError.Internal("Sent a request with the wrong HTTP method. B2 gave message: " +
                    resData.message);
            default:
                throw new errors_1.default.UnknownServerError(resData);
        }
    }
    async upload(fileName, data, options) {
        if (this.inUse)
            throw new errors_1.BackblazeLibraryError.BadUsage("Tried to use a Single Part Upload which is in use.");
        let result;
        try {
            this._inUse = true;
            let { contentLength } = options;
            if (typeof contentLength === "undefined") {
                if (!(data instanceof Buffer))
                    throw new errors_1.BackblazeLibraryError.BadUsage("Single part uploads must have a known contentLength.");
                contentLength = data.length;
            }
            result = await this._upload(fileName, data, { ...options, contentLength }, 0);
            return result;
        }
        finally {
            if (result !== false)
                this._inUse = false;
        }
    }
}
exports.default = SinglePartUpload;
//# sourceMappingURL=single-part-upload.js.map