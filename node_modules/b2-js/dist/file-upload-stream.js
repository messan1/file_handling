"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const crypto_1 = require("crypto");
const stream_1 = require("stream");
const upload_part_1 = tslib_1.__importDefault(require("./api-operations/upload-part"));
const buffer_1 = require("buffer");
const errors_1 = require("./errors");
class PendingPart extends stream_1.Writable {
    constructor() {
        super(...arguments);
        this.chunks = [];
        this.hash = crypto_1.createHash("sha1");
        this.bytes = 0;
    }
    _write(chunk, _, callback) {
        this.hash.update(chunk);
        this.bytes += chunk.byteLength;
        this.chunks.push(chunk);
        callback();
    }
    concat() {
        return buffer_1.Buffer.concat(this.chunks);
    }
    _final(cb) {
        this.digest = this.hash.digest("hex");
        cb();
    }
}
/** @internal */
class FileUploadStream extends stream_1.Writable {
    constructor(file, options = {}) {
        super({});
        this._isMultipart = false;
        this._uploadDigestPromises = [];
        this.uploadUrls = [];
        this.file = file;
        this.options = options;
        this.b2 = file.b2;
        this.pendingPart = new PendingPart();
    }
    __process(chunk, callback) {
        const spaceInPart = this.b2.partSize - this.pendingPart.bytes;
        if (chunk.byteLength > spaceInPart) {
            const part = this.pendingPart;
            this.pendingPart = new PendingPart();
            part.write(chunk.slice(0, spaceInPart));
            part.on("error", callback);
            part.end(() => {
                this.uploadPart(part).then(() => {
                    this.__process(chunk.slice(spaceInPart), callback);
                }, (err) => {
                    callback(err);
                });
            });
        }
        else {
            this.pendingPart.write(chunk, callback);
        }
    }
    _write(chunk, _encoding, callback) {
        this.__process(chunk, callback);
    }
    _final(cb) {
        this._finishUpload().then(() => cb(), (err) => cb(err));
    }
    uploadPart(part) {
        const uploadUrl = this.uploadUrls.pop();
        const partNumber = this._uploadDigestPromises.length + 1;
        const promise = ((this._isMultipart)
            ? Promise.resolve()
            : this.file._startMultipartUpload(this.options)).then(() => upload_part_1.default(partNumber, part.concat(), part.digest, uploadUrl, () => this._getMultipartUploadUrl(), this.options.maxRetries || 5, this.options.backoff || 150));
        this._isMultipart = true;
        this._uploadDigestPromises.push(promise.then((data) => data.data.contentSha1));
        promise.then(({ url }) => {
            this.uploadUrls.push(url);
        });
        return promise;
    }
    async _uploadAsSinglePart() {
        if (this._isMultipart)
            throw new errors_1.BackblazeLibraryError.BadUsage("Cannot upload as single part after beginning a multipart upload.");
        return this.file.uploadSinglePart(this.pendingPart.concat(), {
            ...this.options,
            contentLength: this.pendingPart.bytes,
            sha1: this.pendingPart.digest
        });
    }
    async _finishUpload() {
        this.file["_fileData"] = await (this._uploadDigestPromises.length === 0
            ? this._uploadAsSinglePart()
            : this._finishMultipart());
    }
    async _finishMultipart() {
        await new Promise((res, rej) => {
            this.pendingPart.on("error", rej);
            this.pendingPart.end(res);
        });
        await this.uploadPart(this.pendingPart);
        const res = await this.file.b2.callApi("b2_finish_large_file", {
            method: "POST",
            body: JSON.stringify({
                fileId: await this.file.getFileId(),
                partSha1Array: await Promise.all(this._uploadDigestPromises),
            }),
        });
        return await res.json();
    }
    /** @private */
    async _getMultipartUploadUrl() {
        const res = await this.file.b2.callApi("b2_get_upload_part_url", {
            method: "POST",
            body: JSON.stringify({ fileId: await this.file.getFileId() }),
        });
        return await res.json();
    }
}
exports.default = FileUploadStream;
//# sourceMappingURL=file-upload-stream.js.map