"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BucketType = void 0;
const tslib_1 = require("tslib");
const file_1 = tslib_1.__importDefault(require("./file"));
const single_part_upload_1 = tslib_1.__importDefault(require("./single-part-upload"));
const errors_1 = require("./errors");
var BucketType;
(function (BucketType) {
    BucketType["allPublic"] = "allPublic";
    BucketType["allPrivate"] = "allPrivate";
    BucketType["snapshot"] = "snapshot";
})(BucketType = exports.BucketType || (exports.BucketType = {}));
class Bucket {
    constructor(b2, info) {
        this._singlePartUploads = [];
        this.b2 = b2;
        this.info = info;
    }
    /**
     * Lists files from B2.
     *
     * @internal
     */
    async _getFileDataBatch({ batchSize, startFileName, ...options }) {
        const res = await this.b2.callApi("b2_list_file_names", {
            method: "POST",
            body: JSON.stringify({
                ...options,
                bucketId: await this.getBucketId(),
                maxFileCount: batchSize,
                startFileName,
            }),
        });
        return await res.json();
    }
    /**
     * Lists file data from B2.
     *
     * You probably should use {@linkcode files} instead to get {@linkcode File} objects.
     */
    async *listFileData({ batchSize, startFileName, ...options }) {
        while (true) {
            const { files, nextFileName } = await this._getFileDataBatch(options);
            yield* files;
            if (nextFileName === null)
                break;
            startFileName = nextFileName;
        }
    }
    /**
     * Lists files from B2.
     */
    async *files(options) {
        for await (const fileData of this.listFileData(options)) {
            yield new file_1.default(this, fileData);
        }
    }
    file(arg) {
        return new file_1.default(this, typeof arg === "string" ? { fileName: arg } : arg);
    }
    async getBucketName() {
        if (typeof this.info.bucketName !== "undefined")
            return this.info.bucketName;
        return (await this.refreshBucketInfo()).bucketName;
    }
    async getBucketId() {
        if (typeof this.info.bucketId !== "undefined")
            return this.info.bucketId;
        return (await this.refreshBucketInfo()).bucketId;
    }
    /**
     * Reloads the `info` attribute from B2.
     */
    async refreshBucketInfo() {
        const query = {
            accountId: this.b2["auth"].accountId,
        };
        if (typeof this.info.bucketId !== "undefined") {
            query.bucketId = this.info.bucketId;
        }
        else {
            query.bucketName = this.info.bucketName;
        }
        const res = await this.b2.callApi("b2_list_buckets", {
            method: "POST",
            body: JSON.stringify(query),
        });
        const { buckets: [bucket], } = await res.json();
        if (bucket) {
            return (this.info = bucket);
        }
        else {
            throw new errors_1.BackblazeLibraryError.BadUsage("Bucket missing: " + this.info.bucketName || this.info.bucketInfo);
        }
    }
    async getSinglePartUpload() {
        let upload = this._singlePartUploads.pop();
        if (typeof upload !== "undefined")
            return upload;
        return single_part_upload_1.default.requestNew(this);
    }
    /**
     * Upload a file using a single-part upload.
     *
     * For larger files (recommended for 100MB, but no less than 5MB), see {@linkcode File.createWriteStream}.
     *
     * @param fileName The name of the destination file.
     * @param data Buffer or stream.
     * @param options Must have a `contentLength` attribute
     */
    async uploadSinglePart(fileName, data, options) {
        const singlePartUpload = await this.getSinglePartUpload();
        try {
            const fileData = await singlePartUpload.upload(fileName, data, options);
            return fileData === false
                ? this.uploadSinglePart(fileName, data, options)
                : fileData;
        }
        finally {
            if (!singlePartUpload.inUse)
                this._singlePartUploads.push(singlePartUpload);
        }
    }
    /**
     * Automatically upload Buffers.
     *
     * The library automatically decides whether to conduct a single or multi-part
     * upload based on the Buffer's `byteLength`.
     *
     * ```js
     * // a single-part upload will be attempted.
     * bucket.upload("test.txt", Buffer.from("foobar"));
     *
     * // a multi-part upload will automatically be attempted for larger files
     * bucket.upload("test.txt", Buffer.from("*".repeat(101*1000*1000 /* 101MB *\/)));
     * ```
     *
     * @param fileName The name of the destination file.
     * @param data The file contents.
     * @param options
     */
    async upload(fileName, data, options = {}) {
        const contentLength = data.byteLength;
        if (typeof contentLength !== "undefined" &&
            contentLength <= this.b2.partSize) {
            const fileData = await this.uploadSinglePart(fileName, data, {
                ...options,
                contentLength,
            });
            return new file_1.default(this, fileData);
        }
        else {
            const file = new file_1.default(this, { fileName });
            const writeStream = file.createWriteStream();
            return new Promise((res, rej) => {
                writeStream.on("error", rej);
                writeStream.on("finish", () => {
                    res(file);
                });
                writeStream.end(data);
            });
        }
    }
}
exports.default = Bucket;
//# sourceMappingURL=bucket.js.map