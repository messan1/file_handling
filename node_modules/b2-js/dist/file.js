"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileAction = void 0;
const tslib_1 = require("tslib");
const stream_1 = require("stream");
const errors_1 = require("./errors");
const file_upload_stream_1 = tslib_1.__importDefault(require("./file-upload-stream"));
var FileAction;
(function (FileAction) {
    /** "start" means that a large file has been started, but not finished or canceled */
    FileAction["start"] = "start";
    /** "upload" means a file that was uploaded to B2 Cloud Storage.  */
    FileAction["upload"] = "upload";
    /** "hide" means a file version marking the file as hidden, so that it will not show up in `b2_list_file_names`. */
    FileAction["hide"] = "hide";
    /** "folder" is used to indicate a virtual folder when listing files. */
    FileAction["folder"] = "folder";
})(FileAction = exports.FileAction || (exports.FileAction = {}));
class File {
    /** @internal */
    constructor(bucket, fileData) {
        this._bucket = bucket;
        this._fileData = fileData;
    }
    async getFileName() {
        let { fileName } = this._fileData;
        if (typeof fileName !== "undefined")
            return fileName;
        return (await this.stat()).fileName;
    }
    /**
     * When getting a file's ids by its `fileName`, this is a Class C transaction
     * See https://www.backblaze.com/b2/cloud-storage-pricing.html
     */
    async getFileId() {
        let { fileId } = this._fileData;
        if (typeof fileId !== "undefined" && fileId !== null)
            return fileId;
        return (await this.stat()).fileId;
    }
    getBucketId() {
        return this._bucket.getBucketId();
    }
    getBucketName() {
        return this._bucket.getBucketName();
    }
    /** @internal */
    get b2() {
        return this._bucket.b2;
    }
    /**
     * Gets file data by fileId or fileName.
     *
     * When stating a file without its `fileId`, this is a Class C transaction
     * See https://www.backblaze.com/b2/cloud-storage-pricing.html
     *
     * @throws {@linkcode BackblazeLibraryError.FileNotFound} When a file is not found by name.
     */
    stat() {
        if (typeof this._fileData.fileId !== "undefined" && this._fileData.fileId != null) {
            return this._statById();
        }
        else if (typeof this._fileData.fileName !== "undefined") {
            return this._statByName();
        }
        else {
            throw new errors_1.BackblazeLibraryError.BadUsage("To stat a file, you must provide either its fileId or fileName.");
        }
    }
    async _statById() {
        const res = await this.b2.callApi("b2_get_file_info", {
            method: "POST",
            body: JSON.stringify({
                fileId: await this.getFileId()
            })
        });
        return this._fileData = await res.json();
    }
    async _statByName() {
        const { files: [fileData] } = await this._bucket._getFileDataBatch({ batchSize: 1, startFileName: this._fileData.fileName });
        if (typeof fileData === "undefined" || fileData.fileName !== this._fileData.fileName)
            throw new errors_1.BackblazeLibraryError.FileNotFound("The file was not found.");
        return this._fileData = fileData;
    }
    /**
     * Download this file from B2.
     *
     * ```js
     * const file = bucket.file("text.txt");
     * file.createReadStream();
      ```
     */
    createReadStream() {
        const stream = new stream_1.PassThrough();
        const { fileId, fileName } = this._fileData;
        if (typeof fileId !== "undefined" && fileId != null) {
            this.b2.callDownloadApi("b2_download_file_by_id?fileId=" + encodeURIComponent(fileId), {}).then((res) => {
                res.body.on("error", stream.destroy);
                res.body.pipe(stream);
            });
        }
        else if (typeof fileName !== "undefined") {
            Promise.all([this.getBucketName()]).then(([bucketName]) => this.b2.requestFromDownloadFileByName(bucketName, fileName, {})).then((res) => {
                res.body.on("error", stream.destroy);
                res.body.pipe(stream);
            });
        }
        else {
            throw new errors_1.BackblazeLibraryError.BadUsage("To download a file, you must provide either its fileId or fileName.");
        }
        return stream;
    }
    /**
     * Upload to this file on B2.
     *
     * This works by loading chunks of the stream, upto {@linkcode B2.partSize},
     * into memory. If the stream has less than or equal to that many bytes, a
     * single-part upload will be attempted.
     *
     * Otherwise, a multi-part upload will be attempted by loading up-to
     * `b2.partSize` bytes of the stream into memory at a time.
     *
     * ```js
     * const file = bucket.file("example");
     * const stream = file.createWriteStream();
     * stream.on("error", (err) => {
     *   // handle the error
     *   // note that retries are automatically attempted before errors are
     *   // thrown for most potentially recoverable errors, as per the B2 docs.
     * })
     * stream.on("finish", (err) => {
     *   // upload done, the file instance has been updated to reflect this
     * })
     * res.body.pipe(stream);
     * ```
     */
    createWriteStream() {
        return new file_upload_stream_1.default(this);
    }
    /** @internal */
    async _startMultipartUpload(options) {
        if (this._fileData.action === FileAction.upload)
            return;
        const [bucketId, fileName] = await Promise.all([
            this.getBucketId(),
            this.getFileName(),
        ]);
        const res = await this.b2.callApi("b2_start_large_file", {
            method: "POST",
            body: JSON.stringify({
                bucketId,
                fileName,
                contentType: options.contentType || "application/octet-stream",
                fileInfo: options.fileInfo,
            }),
        });
        this._fileData = await res.json();
    }
    /** @internal */
    async uploadSinglePart(data, options) {
        return this._bucket.uploadSinglePart(await this.getFileName(), data, options);
    }
}
exports.default = File;
//# sourceMappingURL=file.js.map